import "mcpt2_defs.sialx" 
import "mcpt2_vars.sialx"
import "mcpt2_util.sialx"
import "mcpt2_doubles.sialx"
#
                           SIAL FRAG_2ORDER_CORR 
#
# -----------------------------------------------------------------------------
# 
PROC FRAG_TRAN_NO_WC
#     -------------- 

sip_barrier

# ---------------------------------------------------------------------------- 
#     First stage --> form Vxxxj (1122) 
# ---------------------------------------------------------------------------- 

PARDO ifrag, jfrag, mu, nu, lambda "Frag{ij}{aa}{a}"

    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
	  allocate LVxxxq[mu,nu,lambda,j] 
    ENDDO j 

    DO sigma 
    where (int)SwAO_frag[(index)sigma] == jfrag

	  aoint[mu,nu,lambda,sigma]  = 0.0 
	  execute compute_integral_batch aoint[mu,nu,lambda,sigma] #  1 1 2 2  

	  DO j 
	  where (int)SwMOA_frag[(index)j] == jfrag
	      txxxq[mu,nu,lambda,j]   = aoint[mu,nu,lambda,sigma]*ca[sigma,j] 
	      LVxxxq[mu,nu,lambda,j] += txxxq[mu,nu,lambda,j] 
	  ENDDO j 
    ENDDO sigma 

    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag

        put Vxxxq[mu,nu,lambda,j] = LVxxxq[mu,nu,lambda,j]

    ENDDO j 

    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
	  deallocate LVxxxq[mu,nu,lambda,j] 
    ENDDO j 

ENDPARDO ifrag, jfrag, mu, nu, lambda

# Exchange integrals 

PARDO ifrag, jfrag, nu, lambda, mu "Frag{ij}{aa}{a}"

    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
	allocate LVxxxq[mu,nu,lambda,j] 
    ENDDO j 

    DO sigma 
    where (int)SwAO_frag[(index)sigma] == jfrag

	aoint[mu,nu,lambda,sigma]  = 0.0 
	execute compute_integral_batch aoint[mu,nu,lambda,sigma] #  1 1 2 2  

	DO j 
	where (int)SwMOA_frag[(index)j] == jfrag
	    txxxq[mu,nu,lambda,j]   = aoint[mu,nu,lambda,sigma]*ca[sigma,j] 
	    LVxxxq[mu,nu,lambda,j] += txxxq[mu,nu,lambda,j] 
	ENDDO j 

    ENDDO sigma 


    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag

	DO i 
	where (int)SwMOA_frag[(index)i] == ifrag
	    txxqq[mu,nu,i,j]      = LVxxxq[mu,nu,lambda,j]*ca[lambda,i] 
	    PUT Vxxqq_x[mu,nu,i,j] += txxqq[mu,nu,i,j] 
	ENDDO i  
    ENDDO j 

    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
	deallocate LVxxxq[mu,nu,lambda,j] 
    ENDDO j 

ENDPARDO ifrag, jfrag, nu, lambda, mu
#
PARDO ifrag, jfrag, mu, nu, lambda "Frag{ij}{aaa}{}"

    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
	allocate LVxxxq[mu,nu,lambda,j] 
    ENDDO j 

    DO sigma 
    where (int)SwAO_frag[(index)sigma] == jfrag

	aoint[mu,nu,lambda,sigma]  = 0.0 
	execute compute_integral_batch aoint[mu,nu,lambda,sigma] #  1 1 2 2  

	DO j 
	where (int)SwMOA_frag[(index)j] == jfrag
	    txxxq[mu,nu,lambda,j]   = aoint[mu,nu,lambda,sigma]*ca[sigma,j] 
	    LVxxxq[mu,nu,lambda,j] += txxxq[mu,nu,lambda,j] 
	ENDDO j 

    ENDDO sigma 


    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag

	DO i 
	where (int)SwMOA_frag[(index)i] == ifrag
	    txxqq[mu,nu,i,j]      = LVxxxq[mu,nu,lambda,j]*ca[lambda,i] 
	    PUT Vxxqq_x[mu,nu,i,j] += txxqq[mu,nu,i,j] 
	ENDDO i  

    ENDDO j 

    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
	deallocate LVxxxq[mu,nu,lambda,j] 
    ENDDO j 

ENDPARDO ifrag, jfrag, mu, nu, lambda

print "Done first stage of two-electron integral transformation" 
sip_barrier

PARDO ifrag, jfrag, mu, nu, lambda "Frag{ij}{aa}{a}"
    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
          get Vxxxq[mu,nu,lambda,j]
	  DO i1 
	  where (int)SwMOA_frag[(index)i1] == ifrag
	      txpxq[mu,i1,lambda,j]      = Vxxxq[mu,nu,lambda,j]*ca[nu,i1] 
	      PUT Vxpxq[mu,i1,lambda,j] += txpxq[mu,i1,lambda,j] 
	  ENDDO i1 
    ENDDO j 
ENDPARDO ifrag, jfrag, mu, nu, lambda

PARDO ifrag, jfrag, mu, nu, lambda "Frag{ij}{aa}{a}"
    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
          get Vxxxq[mu,nu,lambda,j]
	  DO i1 
	  where (int)SwMOA_frag[(index)i1] == ifrag
	      tpxxq[i1,nu,lambda,j]      = Vxxxq[mu,nu,lambda,j]*ca[mu,i1] 
	      PUT Vpxxq[i1,nu,lambda,j] += tpxxq[i1,nu,lambda,j] 
	  ENDDO i1 
    ENDDO j 
ENDPARDO ifrag, jfrag, mu, nu, lambda

PARDO ifrag, jfrag, mu, nu, lambda "Frag{ij}{aa}{a}"
    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
          get Vxxxq[mu,nu,lambda,j]
	  DO j1  
	  where (int)SwMOA_frag[(index)j1] == jfrag
	      txxqq[mu,nu,j1,j]      = Vxxxq[mu,nu,lambda,j]*ca[lambda,j1] 
	      PUT Vxxqq[mu,nu,j1,j] += txxqq[mu,nu,j1,j] 
	  ENDDO j1  
    ENDDO j 
ENDPARDO ifrag, jfrag, mu, nu, lambda

PARDO ifrag, jfrag, mu, nu, lambda "Frag{ij}{aa}{a}"
    DO j 
    where (int)SwMOA_frag[(index)j] == jfrag
	get Vxxxq[mu,nu,lambda,j]
	DO a1
	where (int)SwMOA_frag[(index)a1] == jfrag
	    txxqq[mu,nu,a1,j]= Vxxxq[mu,nu,lambda,j]*ca[lambda,a1] 
	    PUT Vxxai[mu,nu,a1,j] += txxqq[mu,nu,a1,j] 
	ENDDO a1
    ENDDO j 
ENDPARDO ifrag, jfrag, mu, nu, lambda

sip_barrier 
print "Done second stageof two-electron integral transformation" 

# ---------------------------------------------------------------------------- 
#     Third stage --> form Vxibj (1122) 
# ---------------------------------------------------------------------------- 

PARDO ifrag, jfrag, mu, i, lambda, j "Frag{ij}{ao}{ao}"

    GET                    Vxpxq[mu,i,lambda,j] 
    DO b 
    where (int)SwMOA_frag[(index)b] == jfrag
	txpqq[mu,i,b,j]      = Vxpxq[mu,i,lambda,j]*ca[lambda,b] 
	PUT Vxpbq[mu,i,b,j] += txpqq[mu,i,b,j] 
    ENDDO b 

ENDPARDO ifrag,jfrag, mu, i, lambda, j

# ---------------------------------------------------------------------------- 
#     Third stage --> form Vixbj (1122) 
# ---------------------------------------------------------------------------- 
#
PARDO ifrag, jfrag, nu, i, lambda, j "Frag{ij}{ao}{ao}"

    GET                    Vpxxq[i,nu,lambda,j] 

    DO b 
    where (int)SwMOA_frag[(index)b] == jfrag
	tpxqq[i,nu,b,j]      = Vpxxq[i,nu,lambda,j]*ca[lambda,b] 
	PUT Vixbj[i,nu,b,j] += tpxqq[i,nu,b,j] 
    ENDDO b 

    DO j1 
    where (int)SwMOA_frag[(index)j1] == jfrag
	tpxqq[i,nu,j1,j]      = Vpxxq[i,nu,lambda,j]*ca[lambda,j1] 
	PUT Vixjj[i,nu,j1,j] += tpxqq[i,nu,j1,j] 
    ENDDO j1  
ENDPARDO ifrag,jfrag, nu, i, lambda, j
#
PARDO ifrag, jfrag, nu, mu, j, j1 "Frag{ij}{aa}{oo}"

    GET                 Vxxqq[mu,nu,j1,j] 

    DO a 
    where (int)SwMOA_frag[(index)a] == ifrag
	tpxqq[a,nu,j1,j]      = Vxxqq[mu,nu,j1,j]*ca[mu,a] 
	PUT Vaxjj[a,nu,j1,j] += tpxqq[a,nu,j1,j] 
    ENDDO a 

ENDPARDO ifrag,jfrag, nu, mu, j, j1
#
PARDO ifrag, jfrag,nu,i,mu,j "Frag{ij}{ao}{ao}"

    GET                 Vxxqq_x[mu,nu,i,j] 

    DO i1 
    where (int)SwMOA_frag[(index)i1] == ifrag
	txpqq[mu,i1,i,j]      = Vxxqq_x[mu,nu,i,j]*ca[nu,i1] 
	PUT Vxiij[mu,i1,i,j] += txpqq[mu,i1,i,j] 
    ENDDO i1  

ENDPARDO ifrag, jfrag,nu,i,mu,j

PARDO ifrag, jfrag,nu,i,mu,j "Frag{ij}{aoa}{o}" ####line 407

    GET                 Vxxqq_x[mu,nu,i,j] 

    DO i1 
    where (int)SwMOA_frag[(index)i1] == ifrag
	txpqq[mu,i1,i,j]      = Vxxqq_x[mu,nu,i,j]*ca[nu,i1] 
	pUT Vxiij[mu,i1,i,j] += txpqq[mu,i1,i,j] 
    ENDDO i1  

ENDPARDO ifrag, jfrag,nu,i,mu,j

PARDO ifrag, jfrag, mu, nu, b, j "Frag{ij}{aa}{vo}"

    get Vxxai[mu,nu,b,j]

    do a1
    where (int)SwMOA_frag[(index)a1] == ifrag
	tpxqq[a1,nu,b,j]= Vxxai[mu,nu,b,j]*ca[mu,a1]
	PUT Vaxaj[a1,nu,b,j] += tpxqq[a1,nu,b,j]
    enddo a1

ENDPARDO ifrag, jfrag, mu, nu, b, j

print "Done third stage of two-electron integral transformation" 
sip_barrier 

# ---------------------------------------------------------------------------- 
#     Fourth stage --> form Vaibj (1122) 
# ---------------------------------------------------------------------------- 

PARDO ifrag, jfrag, mu, i, b, j "Frag{ij}{ap}{pp}"

GET               Vxpbq[mu,i,b,j] 

DO a 
where (int)SwMOA_frag[(index)a] == ifrag
tppqq[a,i,b,j]      = Vxpbq[mu,i,b,j]*ca[mu,a] 
PUT Vaibj[a,i,b,j] += tppqq[a,i,b,j] 
ENDDO a 

ENDPARDO ifrag, jfrag, mu, i, b, j

# ---------------------------------------------------------------------------- 
#     Fourth stage --> form Viabj (1122) 
# ---------------------------------------------------------------------------- 
PARDO ifrag, jfrag, nu, i, b, j  "Frag{ij}{ap}{pp}"

    GET               Vixbj[i,nu,b,j]  

    DO a 
    where (int)SwMOA_frag[(index)a] == ifrag
	tppqq[i,a,b,j]      = Vixbj[i,nu,b,j]*ca[nu,a] 
	PUT Viabj[i,a,b,j] += tppqq[i,a,b,j] 
    ENDDO a 

ENDPARDO ifrag,jfrag, nu, i, b, j

PARDO ifrag, jfrag, nu, a, j, j1 "Frag{ij}{ap}{pp}"

    GET                Vaxjj[a,nu,j1,j] 

    DO a1 
    where (int)SwMOA_frag[(index)a1] == ifrag
	tppqq[a,a1,j1,j]      = Vaxjj[a,nu,j1,j]*ca[nu,a1] 
	PUT Vaajj[a,a1,j1,j] += tppqq[a,a1,j1,j] 
    ENDDO a1 

ENDPARDO ifrag,jfrag, nu, a, j, j1

# ---------------------------------------------------------------------------- 
#     Fourth stage --> form Viijj (1122) 
# ---------------------------------------------------------------------------- 
#
PARDO ifrag, jfrag, nu, i, j, j1  "Frag{ij}{ap}{pp}"

    GET                Vixjj[i,nu,j1,j] 

    DO i1 
    where (int)SwMOA_frag[(index)i1] == ifrag
	tppqq[i,i1,j1,j]      = Vixjj[i,nu,j1,j]*ca[nu,i1] 
	PUT Viijj[i,i1,j1,j] += tppqq[i,i1,j1,j] 
    ENDDO i1 

ENDPARDO ifrag, jfrag, nu, i, j, j1

PARDO jfrag, ifrag, mu, j, i, i1  "Frag{ij}{ap}{pp}"

    GET                 Vxiij[mu,i1,i,j] 

    DO j1 
    where (int)SwMOA_frag[(index)j1] == jfrag
	tppqq[j1,i1,i,j]      = Vxiij[mu,i1,i,j]*ca[mu,j1] 
	PUT Vjiij[j1,i1,i,j] += tppqq[j1,i1,i,j] 
    ENDDO j1  

ENDPARDO jfrag, ifrag, mu, j, i, i1

PARDO ifrag, jfrag, mu, i, i1, j "Frag{ij}{aoo}{o}" ######## line 532

    GET                 Vxiij[mu,i1,i,j] 

    DO j1 
    where (int)SwMOA_frag[(index)j1] == ifrag
	tppqq[j1,i1,i,j]      = Vxiij[mu,i1,i,j]*ca[mu,j1] 
	PUT Viiij[j1,i1,i,j] += tppqq[j1,i1,i,j] 
    ENDDO j1  

ENDPARDO ifrag, jfrag, mu, i, i1, j

PARDO ifrag, jfrag, nu, i, j, j1  "Frag{ij}{ap}{pp}"

    GET          Vixjj[i,nu,j1,j] 

    DO a1 
    where (int)SwMOA_frag[(index)a1] == ifrag
	tppqq[i,a1,j1,j]= Vixjj[i,nu,j1,j]*ca[nu,a1] 
	PUT Viaii[i,a1,j1,j] += tppqq[i,a1,j1,j] 
    ENDDO a1 

ENDPARDO ifrag, jfrag, nu, i, j, j1

PARDO ifrag, jfrag, nu, a, b, j "Frag{ij}{ap}{pp}"

    get Vaxaj[a,nu,b,j]

    do a1
    where (int)SwMOA_frag[(index)a1] == ifrag
	tppqq[a,a1,b,j]= Vaxaj[a,nu,b,j]*ca[nu,a1]
	PUT Vaaai[a,a1,b,j] += tppqq[a,a1,b,j]
    enddo a1

ENDPARDO ifrag, jfrag, nu, a, b, j

print "Done fourth stage of transformation" 

      sip_barrier 
#
      ENDPROC FRAG_TRAN_NO_WC
#
# -----------------------------------------------------------------------------
# 
      PROC OVERLAP_EXCHANGE 
#     ----------------- 
#
#     Form the contribution /sum_C V(a,i,C,C) 
#
      sip_barrier 
#
# Form the contribution from /sum_C Hai(C) 
#

      PARDO ifrag, mu, nu "Frag{i}{aa}{}"

         icount = (scalar)ifrag

               txx[mu,nu] = 0.0 
               execute return_h1frag txx[mu,nu] icount  

               do i 
	       where (int)SwMOA_frag[(index)i] == ifrag

                     tpx[i,nu] = txx[mu,nu]*ca[mu,i] 

                     do j 
		     where (int)SwMOA_frag[(index)j] == ifrag
                           t1pp[i,j] = tpx[i,nu]*ca[nu,j] 
                           PUT VE[i,j] += t1pp[i,j] 
                     enddo j 

               enddo i 

      ENDPARDO ifrag, mu, nu

      PARDO ifrag,jfrag, mu, nu "Frag{Nij}{a}{a}" #line 713

         icount = (scalar)ifrag
         jcount = (scalar)jfrag

                  txx[mu,nu] = 0.0 
                  execute return_h1frag txx[mu,nu] icount  

               do i 
	       where (int)SwMOA_frag[(index)i] == ifrag

                     tpx[i,nu] = txx[mu,nu]*ca[mu,i] 

                     do j 
	             where (int)SwMOA_frag[(index)j] == jfrag
                           t1pp[i,j] = tpx[i,nu]*ca[nu,j] 
                           PUT VE_x[i,j] += t1pp[i,j] 
                     enddo j 

               enddo i 

      ENDPARDO ifrag,jfrag, mu, nu

      sip_barrier 

      PARDO ifrag,jfrag
      where ifrag != jfrag
	 icount = (scalar)ifrag
	 jcount = (scalar)jfrag
#
         DO mu
	 where (int)SwAO_frag[(index)mu] == ifrag
         DO nu
	 where (int)SwAO_frag[(index)nu] == jfrag

	      execute return_ovl txx[mu,nu]  
	      PUT oed_ovl[mu,nu] = txx[mu,nu] 

         ENDDO nu
         ENDDO mu

      ENDPARDO ifrag,jfrag
      sip_barrier 
# 
      PARDO ifrag,jfrag
      where ifrag != jfrag
	 icount = (scalar)ifrag
	 jcount = (scalar)jfrag
#
         DO mu
	 where (int)SwAO_frag[(index)mu] == ifrag
         DO nu
	 where (int)SwAO_frag[(index)nu] == jfrag

	      GET oed_ovl[mu,nu] 

              DO a
	      where (int)SwMOA_frag[(index)a] == jfrag
              DO i
	      where (int)SwMOA_frag[(index)i] ==ifrag

                    txp[mu,a] = oed_ovl[mu,nu]*ca[nu,a]  
                    tpp[i,a]  = txp[mu,a]*ca[mu,i] 
                    PUT SOVL[i,a] += tpp[i,a] 

              ENDDO i
              ENDDO a

              DO i1  
	      where (int)SwMOA_frag[(index)i1] == jfrag
              DO i
	      where (int)SwMOA_frag[(index)i] == ifrag

                    txp[mu,i1] = oed_ovl[mu,nu]*ca[nu,i1]  
                    tpp[i,i1]  = txp[mu,i1]*ca[mu,i] 
                    PUT SOVL[i,i1] += tpp[i,i1] 

              ENDDO i
              ENDDO i1  

              DO a1  
	      where (int)SwMOA_frag[(index)a1] == jfrag
              DO a
	      where (int)SwMOA_frag[(index)a] == ifrag

                    txp[mu,a1] = oed_ovl[mu,nu]*ca[nu,a1]  
                    tpp[a,a1]  = txp[mu,a1]*ca[mu,a] 
                    PUT SOVL[a,a1] += tpp[a,a1] 

              ENDDO a
              ENDDO a1  

         ENDDO nu
         ENDDO mu

      ENDPARDO ifrag,jfrag
      sip_barrier

# 
      PARDO ifrag,jfrag
      where ifrag != jfrag
	 icount = (scalar)ifrag
	 jcount = (scalar)jfrag
#
         esum = 0.0 

         if (int)elst_dist[ifrag,jfrag] == ifrag
#
         DO a
	 where (int)SwMOA_frag[(index)a] == ifrag
         DO i
	 where (int)SwMOA_frag[(index)i] == ifrag

               DO b
	       where (int)SwMOA_frag[(index)b] == jfrag
               DO j
	       where (int)SwMOA_frag[(index)i] == jfrag
                     GET Vaibj[a,i,b,j] 
                     GET SOVL[j,a] 
                     GET SOVL[i,b] 
                     tpp[a,j] = Vaibj[a,i,b,j]*SOVL[i,b]  
                     etemp = SOVL[j,a]*tpp[a,j] 

                     etemp*= -1.0  # Not 2 to avoid overcounting ??? 
                     esum += etemp 
               ENDDO j
               ENDDO b
         ENDDO i
         ENDDO a
         endif # pair_flag > zero  

         t20disp[ifrag,jfrag]      = esum   
         PUT e10exch[ifrag,jfrag] += t20disp[ifrag,jfrag] 

      ENDPARDO ifrag,jfrag

      sip_barrier

      sip_barrier
      e1exc_at = 0.0  
      esum = 0.0 

      PARDO ifrag, jfrag  
	  put e10exch[ifrag,jfrag] = 0.0
      endPARDO ifrag, jfrag  
      sip_barrier 

# 1st-term 
      PARDO ifrag, jfrag, i, j "Frag{Nij}{o}{o}"

         DO i1 
	 where i==i1
         DO j1 
         where j == j1 
                  GET                Vjiij[j1,i1,i,j] 
                  tpppp[i,i1,j,j1] = Vjiij[j1,i1,i,j] 
                  etemp = 0.0 
                  execute return_diagonal tpppp[i,i1,j,j1] etemp
                  etemp *= -1.0 
                  esum += etemp 
         ENDDO j1 

         ENDDO i1 

	 put e10exch[ifrag,jfrag] += esum
# 
      ENDPARDO ifrag, jfrag, i, j

# second-term 
      PARDO ifrag, jfrag, i2, j "Frag{Nij}{o}{o}"

	      GET SOVL[j,i2] 
	      tpp[i2,j] = 0.0 

	     DO i
	     where (int)SwMOA_frag[(index)i] == ifrag
	     DO i1 
	     where i == i1 
		  GET                 Viiij[i,i1,i2,j] 
		  GET                 Viiij[i2,i1,i,j] 
		  tpppp[i2,j,i,i1]  = Viiij[i,i1,i2,j] 
		  tpppp[i2,j,i,i1] *= 2.0  
		  t1pppp[i2,j,i,i1] = Viiij[i2,i1,i,j]   
		  tpppp[i2,j,i,i1] -= t1pppp[i2,j,i,i1] 

		  Ipp[i,i1] = 1.0 
		  execute return_diagonal Ipp[i,i1] etemp  

		  t1pp[i2,j] = tpppp[i2,j,i,i1] * Ipp[i,i1] 
		  tpp[i2,j] += t1pp[i2,j] 

	     ENDDO i1 
	     ENDDO i 

	      GET          VE_x[j,i2] 
	      GET          VE_x[i2,j] 
	      t1pp[i2,j] = VE_x[j,i2] 
	      t1pp[i2,j]+= VE_x[i2,j] 
	      t1pp[i2,j]*= 0.5  
	      tpp[i2,j] += t1pp[i2,j] 
	      etemp = SOVL[j,i2]*tpp[i2,j] 
	      etemp *= -2.0 
	      esum += etemp 

	 put e10exch[ifrag,jfrag] += esum
# 
      ENDPARDO ifrag, jfrag, i2, j

# Third-term 
      PARDO ifrag, jfrag, j, j1 "Frag{Nij}{oo}{}"

	      tpp[j1,j] = 0.0 
	      t3pp[j,j1] = 0.0 

	     DO i
	     where (int)SwMOA_frag[(index)i] == jfrag
	     DO i1 
	     where i == i1 
		      GET Viijj[j1,j,i,i1] 
		      tpp[i,i1] = 2.0 
		      execute return_diagonal tpp[i,i1] etemp  
		      t2pp[j1,j] = Viijj[j1,j,i,i1]*tpp[i,i1] 
		      tpp[j1,j] += t2pp[j1,j] 
	     ENDDO i1 
	     ENDDO i 

	     DO i2 
	     where (int)SwMOA_frag[(index)i2] == jfrag

                  GET SOVL[j,i2] 
                  GET SOVL[i2,j1] 

                  t1pp[j,j1] = SOVL[j,i2]*SOVL[i2,j1] 
                  t3pp[j,j1] += t1pp[j,j1] 

	     ENDDO i2 

	      etemp = t3pp[j,j1]*tpp[j1,j] 
	      etemp *= 2.0 
	      esum += etemp 

	 put e10exch[ifrag,jfrag] += esum
# 
      ENDPARDO ifrag, jfrag, j, j1


# Fourth-term 
      PARDO ifrag, jfrag, i1, j "Frag{Nij}{o}{o}"

                  tpp[i1,j] = 0.0 
                  GET         SOVL[j,i1] 

               DO i
	       where (int)SwMOA_frag[(index)i] == ifrag

                     DO j1  
	             where (int)SwMOA_frag[(index)j1] == jfrag
                           GET         Viijj[i1,i,j1,j] 
                           GET         SOVL[i,j1] 
                           t1pp[i1,j] = Viijj[i1,i,j1,j]*SOVL[i,j1] 
                           tpp[i1,j] += t1pp[i1,j] 
                     ENDDO j1 
               ENDDO i 

               etemp     = tpp[i1,j]*SOVL[j,i1]
               etemp    *= -1.0 
               esum     += etemp 

	 put e10exch[ifrag,jfrag] += esum

      ENDPARDO ifrag, jfrag, i1, j 


      PARDO ifrag, jfrag, i, i1 "Frag{Nij}{oo}{}"

               DO j
	       where (int)SwMOA_frag[(index)j] == jfrag
		       GET         VE[i1,i] 
		       GET         SOVL[j,i1] 
		       GET         SOVL[i,j] 
		       tpp[i1,j] = VE[i1,i]*SOVL[i,j] 
		       etemp     = tpp[i1,j]*SOVL[j,i1]
		       etemp    *=  2.0  
		       esum     += etemp 
               ENDDO j 

	 put e10exch[ifrag,jfrag] += esum
# 
      ENDPARDO ifrag, jfrag, i, i1

      sip_barrier
      collective e1exc_at += esum   
      print e1exc_at 
# 
      execute get_my_rank rank
      if rank == 0.0
	 do ifrag
         do jfrag
	 where ifrag != jfrag
         where (int)elst_dist[ifrag,jfrag] == ifrag
	     icount = (scalar)ifrag
	     jcount = (scalar)jfrag

	     allocate contiguous final_e10exch[ifrag:ifrag,jfrag:jfrag]
	     get e10exch[ifrag,jfrag]
	     final_e10exch[ifrag:ifrag,jfrag:jfrag] = e10exch[ifrag,jfrag]
	     print final_e10exch[ifrag:ifrag,jfrag:jfrag]
	     deallocate contiguous final_e10exch[ifrag:ifrag,jfrag:jfrag]

	 enddo jfrag
	 enddo ifrag
      endif
#
      ENDPROC OVERLAP_EXCHANGE 
#
# -----------------------------------------------------------------------------
# 
      PROC FEF_END_PRINT
      server_barrier
      print " "
      print "------------------------------------------------------"
      print " "
      restore_persistent gas_scf_energy "total_gas_scf_energy"
      restore_persistent pol_scf_energy "frag_pol_scf_energy"
      total_scf_energy  = pol_scf_energy
      total_scf_energy += e1exc_at

      eint_tot  = gas_scf_energy
      eint_tot *= -1.0
      eint_tot += total_scf_energy
      eint_tot += dimer_doubles  
      eint_tot += fragment_doubles  
      eint_tot += mono_lccd   

      mcpt_corr  = dimer_doubles  
      mcpt_corr += fragment_doubles  

      print pol_scf_energy
      print e1exc_at
      print total_scf_energy
      print " "

      print dimer_doubles
      print fragment_doubles
      print mcpt_corr
      print " "

      mono_lccd *= -1.0
      print mono_lccd  
      print " "

      print eint_tot 
      sip_barrier

      ENDPROC FEF_END_PRINT
#
# -----------------------------------------------------------------------------
# 
#     START OF MAIN PROGRAM  
#
# -----------------------------------------------------------------------------

print " "
print "-- Fragment Effective Field Coupled-Cluster Perturbation Theory"
print "-- Written by Jason N. Byrd, 2016"
print " "

# 
#     Set fragment parameters   
#     ----------------------- 
#
      sip_barrier
      restore_persistent Dca "ca" 
      restore_persistent DFock_a "fock_a"
      rmaster = 0
      do_nonhf = 0
      zero = 0.0 
      one  = 1.0 
      print r_thresh 
      print elst_thresh 
      mone = -1.0 
      print cc_conv 
      sip_barrier
#
      CALL SET_FRAG_PARMS   
      sip_barrier 
      print "Done setting fragment parameters" 
      call set_fock_mos
      sip_barrier 
      CALL FRAG_TRAN_NO_WC
      sip_barrier 
      call OVERLAP_EXCHANGE
      sip_barrier 
# compute the fef-ccpt2 amplitudes
      call DOUBLES_MANAGER
# Compute the LCCD amplitudes for each monomer
      CALL FORM_T2_MONOMER  
#
      call FEF_END_PRINT
      sip_barrier

         sip_barrier 

                           ENDSIAL FRAG_2ORDER_CORR 
##
###############################################################################
