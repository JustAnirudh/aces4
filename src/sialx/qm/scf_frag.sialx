#  Copyright (c) 2003-2010 University of Florida
import "scf_frag_defs.sialx"
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
#
                           SIAL SCF_FRAGMENT 
#
# ----------------------------------------------------------------------------
#
# Declare indeces 
# --------------- 
#
      index   kiter  = 1, scf_iter  
      index   katom  = 1, 4 # Nfrags  
      index   jatom  = 1, 4 # Nfrags  

      aoindex mu = 1, norb 
      aoindex nu = 1, norb 
#
      moaindex i = baocc, eaocc  
      moaindex i1= baocc, eaocc  
#
      mobindex j = bbocc, ebocc  
      mobindex j1= bbocc, ebocc  
#
      moaindex a = bavirt, eavirt   
#
      moaindex p = baocc, eavirt
      moaindex p1= baocc, eavirt
#
      mobindex q = bbocc, ebvirt
      mobindex q1= bbocc, ebvirt
#
      temp Txx(mu,nu) 
      temp txp(mu,p)  
      temp txq(mu,q)  
      temp tpp(p,p1)  
      temp tqq(q,q1)  
      distributed Da(mu,nu) 
      distributed Db(mu,nu) 
      distributed Nai_d(mu,nu) 
      static atom(katom,jatom) 
      temp tatom(katom,jatom) 
      distributed DCa(mu,p) 
      distributed DCb(mu,q) 
      distributed Dfock_a(p,p1) 
      distributed Dfock_b(q,q1) 

      static Ca(mu,p) 
      static Cb(mu,q) 
      static Fock_a(p, p1) 
      static Fock_b(q, q1) 
      static oed_ovl(mu,nu) 
#
# Declare scalars 
# --------------- 
#
      scalar etemp 
      scalar one 
      scalar two 
      scalar rank 
      scalar nfrags 
      scalar fcount 
      scalar imax  
      scalar zmax  
      scalar esum 
#
# ---------------------------------------------------------------------------- 
#
      PROC IGUESS   
#     ----------- 
#
#     Determine the number of fragments  
#     --------------------------------- 
####      execute set_frag nfrags

       etemp = 0.0 
       DO katom 
       DO jatom 
         IF katom == jatom 
          etemp             = etemp + 1.0  
          atom(katom,jatom) = etemp 
         endif 
       ENDDO jatom 
       ENDDO katom 
      print_scalar etemp  

#     Get memory requirements from integral calculation 
#     ------------------------------------------------- 
      println "Starting scratch memory calculation" 
      imax = 0.0  
      zmax = 0.0  
     #DO mu 
     #DO nu 
     #   txx(mu,nu) = 0.0
     #   execute compute_int_scratchmem txx(mu,nu) zmax imax 
         execute compute_int_scratchmem oed_ovl zmax imax 
     #ENDDO nu 
     #ENDDO mu 
      println "Done computing scratch memory" 

# Compute the overlap matrix 
       DO mu 
       DO nu 
          execute return_ovl txx(mu,nu) 
          oed_ovl(mu,nu) = txx(mu,nu)  
       ENDDO nu 
       ENDDO mu
      println "Done computing overlap integrals" 

       do p 
       do mu 
          ca(mu,p) = 0.0
       enddo mu
       enddo p 
       do p 
       do p1  
          Fock_a(p,p1) = 0.0 
       enddo p1  
       enddo p
       do q 
       do mu 
          cb(mu,q) = 0.0
       enddo mu
       enddo q 
       do q 
       do q1  
          Fock_b(q,q1) = 0.0 
       enddo q1  
       enddo q

#
      sip_barrier 

      PARDO katom  
            DO jatom 
               IF katom == jatom  

                  tatom(katom,jatom) = atom(katom,jatom) 
                  execute return_sval tatom(katom,jatom) etemp   
                  print_scalar etemp 
                  do p 
                  do mu 
                     ca(mu,p) = 0.0
                  enddo mu
                  enddo p 
                  do p 
                  do p1  
                     Fock_a(p,p1) = 0.0 
                  enddo p1  
                  enddo p
                  do q 
                  do mu 
                     cb(mu,q) = 0.0
                  enddo mu
                  enddo q 
                  do q 
                  do q1  
                     Fock_b(q,q1) = 0.0 
                  enddo q1  
                  enddo q

                  execute scf_atom etemp Ca Cb Fock_a Fock_b oed_ovl  

                  DO p  
                  DO p1
                     tpp(p,p1)          = fock_a(p,p1) 
                     PUT Dfock_a(p,p1) += tpp(p,p1) 
                  ENDDO p1
                  ENDDO p  

                  DO mu  
                  DO p 
                    #txp(mu,p)      = ca(mu,p) 
                     PUT DCa(mu,p) += ca(mu,p) 
                  ENDDO p 
                  ENDDO mu  

                  DO q  
                  DO q1
                     tqq(q,q1)          = fock_b(q,q1) 
                     PUT Dfock_b(q,q1) += tqq(q,q1) 
                  ENDDO q1
                  ENDDO q  
                  DO mu  
                  DO q 
                     txq(mu,q)      = cb(mu,q) 
                     PUT DCb(mu,q) += txq(mu,q) 
                  ENDDO q 
                  ENDDO mu  

                  esum = 0.0 
                  DO mu  
                  DO p 
                     GET DCa(mu,p) 
                     etemp = DCa(mu,p) * DCa(mu,p) 
                     esum += etemp 
                  ENDDO p 
                  ENDDO mu  
                  print_scalar esum 

                  esum = 0.0 
                  DO mu  
                  DO i 
                     GET DCa(mu,i) 
                     etemp = DCa(mu,i) * DCa(mu,i) 
                     esum += etemp 
                  ENDDO i 
                  ENDDO mu  
                  print_scalar esum 

                  esum = 0.0 
                  DO mu  
                  DO a 
                     GET DCa(mu,a) 
                     etemp = DCa(mu,a) * DCa(mu,a) 
                     esum += etemp 
                  ENDDO a 
                  ENDDO mu  
                  print_scalar esum 
 
              ENDIF # katom == jatom  
            ENDDO jatom 
      ENDPARDO katom   
#
      ENDPROC IGUESS   
#     -------------- 
#
# -----------------------------------------------------------------------------
#
#     Compute the fragment SCF  
#     ------------------------- 
#
      create DCa 
      create DCb 
      create Dfock_a 
      create Dfock_b 
      sip_barrier 
      CALL IGUESS  
      sip_barrier

      esum = 0.0 
      DO mu  
      DO p 
         GET DCa(mu,p) 
         etemp = DCa(mu,p) * DCa(mu,p) 
         esum += etemp 
      ENDDO p 
      ENDDO mu  
      print_scalar esum 

      esum = 0.0 
      DO mu  
      DO i 
         GET DCa(mu,i) 
         etemp = DCa(mu,i) * DCa(mu,i) 
         esum += etemp 
      ENDDO i 
      ENDDO mu  
      print_scalar esum 

      esum = 0.0 
      DO mu  
      DO a 
         GET DCa(mu,a) 
         etemp = DCa(mu,a) * DCa(mu,a) 
         esum += etemp 
      ENDDO a 
      ENDDO mu  
      print_scalar esum 
      sip_barrier

      DO mu  
      DO p 
         GET        DCa(mu,p) 
         ca(mu,p) = DCa(mu,p) 
      ENDDO p 
      ENDDO mu  
      sip_barrier

      DO mu  
      DO q 
         txq(mu,q)      = cb(mu,q) 
        #PUT DCb(mu,q) += txq(mu,q) 
      ENDDO q 
      ENDDO mu  
      sip_barrier

      DO mu  
      DO q 
         GET        DCb(mu,q) 
         cb(mu,q) = DCb(mu,q) 
      ENDDO q 
      ENDDO mu  
      sip_barrier

      DO p  
      DO p1
         tpp(p,p1)          = fock_a(p,p1) 
        #PUT Dfock_a(p,p1) += tpp(p,p1) 
      ENDDO p1
      ENDDO p  
      sip_barrier

      DO p  
      DO p1
         GET            Dfock_a(p,p1) 
         fock_a(p,p1) = Dfock_a(p,p1) 
      ENDDO p1
      ENDDO p  
      sip_barrier

      DO q  
      DO q1
         tqq(q,q1)          = fock_b(q,q1) 
        #PUT Dfock_b(q,q1) += tqq(q,q1) 
      ENDDO q1
      ENDDO q  
      sip_barrier

      DO q  
      DO q1
         GET            Dfock_b(q,q1) 
         fock_b(q,q1) = Dfock_b(q,q1) 
      ENDDO q1
      ENDDO q  

      sip_barrier

      set_persistent Dca "ca" 
      set_persistent DFock_a "fock_a"

# -----------------------------------------------------------------------------
#
                           ENDSIAL SCF_FRAGMENT 
#
###############################################################################
